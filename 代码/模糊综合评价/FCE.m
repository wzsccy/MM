eval_mat=[0.8,0.15,0.05,0,0;
          0.2,0.6,0.1,0,0;
          0.5,0.4,0.1,0,0;
          0.1,0.3,0.5,0.05,0.05;
          0.3,0.5,0.15,0.05,0;
          0.2,0.2,0.4,0.1,0.1;
          0.4,0.4,0.1,0.1,0;
          0.1,0.3,0.3,0.2,0.1;
          0.3,0.2,0.2,0.2,0.1;
          0.1,0.3,0.5,0.1,0;
          0.2,0.3,0.3,0.1,0.1;
          0.2,0.3,0.35,0.15,0;
          0.1,0.3,0.4,0.1,0.1;
          0.1,0.4,0.3,0.1,0.1;
          0.3,0.4,0.2,0.1,0;
          0.1,0.4,0.3,0.1,0.1;
          0.2,0.3,0.4,0.1,0;
          0.4,0.3,0.2,0.1,0];
disp('Eval Matrix:');
disp(eval_mat);


[m,n]=size(eval_mat);
%disp([m,n]);

%% 将上面的矩阵通过下标进行分组，每一组代表一个属性
separation_points=[0,4,9,14];
%然后再输出每一个属性下二级属性的权重
w_mat={[0.2,0.3,0.3,0.2];
    [0.3,0.2,0.1,0.2,0.2];
    [0.1,0.2,0.3,0.2,0.2];
    [0.3,0.2,0.2,0.3]
    };
%输出一级属性的权重
w_vec=[0.4,0.3,0.2,0.1];

%% 计算一级评判向量和二级评判矩阵
separation_points(end+1)=m;
eval_mat_seconds=[];%开辟一个空间存放矩阵
for i=1:length(separation_points)-1
     % 计算每个区间的二级评判矩阵
    temp_mat = eval_mat(separation_points(i)+1:separation_points(i+1),:);
    disp("二级评判区间为：");
    disp(temp_mat);
    % 使用 w_mat{i} 对 temp_mat 进行加权求和
    eval_mat_seconds = [eval_mat_seconds; w_mat{i} * temp_mat];
end
disp("一级评判向量为：");
disp(eval_mat_seconds);


%% 计算二级评判向量，如果只有两级，即为最终结果
eval_vec=w_vec*eval_mat_seconds;
disp("最终的评价向量为：");
disp(eval_vec);






























