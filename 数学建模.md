  # 层次分析法

* 只有非一致矩阵才需要进行一致性检测

* ==要先进行一致性检测，通过后才能求权重！！！==


  ## 步骤

![image-20250121103417269](./数学建模.assets/image-20250121103417269.png)

  ## 代码实现

~~~matlab
%% 识别判断矩阵
disp('请输入判断矩阵A')
A=input('A=');
[n,n]=size(A);
%% 计算一致性比例CR
CI=(Max_eig-n)/(n-1);
RI=[0 0.0001 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59];%这里的RI最多支持n等于15
CR=CI/RI(n);
disp('最大特征值为：');
disp(Max_eig);
disp('一致性指标CI=');disp(CI);
disp('一致性比例CR=');disp(CR);
if CR<0.10
    disp('CR<0.01,该判断矩阵的一致性可以接受');
else 
    disp('注意：CR>=0.10,该判断矩阵需要进行修改！');
end
%% 方法1：算术平均法求权重
Sum_A=sum(A);%将矩阵按列去和
SUM_A=repmat(Sum_A,n,1);%将矩阵A作为元素填充到n行1列的矩阵里
Stand_A=A./SUM_A;
disp('计算算数平均值的结果:');
w1=sum(Stand_A,2)./n;
disp(w1)
%% 方法2：特征值法求权重
[V,D]=eig(A);%求矩阵A的全部特征值，构成对角阵D，并求A的向量构成列向量（V中的每一列都是D中与之相同列的特征值的特征向量）
Max_eig=max(max(D));%先行后列，求最大特征值
[r,c]=find(D==Max_eig,1);%找到最大特征值，返回前一个最大特征值的行列值
disp('特征值求权重的结果为：');
w2=V(:,c)./sum(V(:,c));
disp(w2)  
disp('两种方法的平均权值为：  ');
disp((w1+w2)./2); 
~~~

  # 模糊综合评价

* 权重做乘数，矩阵做被乘


  ## 步骤

![image-20250121103926851](./数学建模.assets/image-20250121103926851.png)

  ## 代码示例

  ~~~matlab
  eval_mat=[0.8,0.15,0.05,0,0;
            0.2,0.6,0.1,0,0;
            0.5,0.4,0.1,0,0;
            0.1,0.3,0.5,0.05,0.05;
            0.3,0.5,0.15,0.05,0;
            0.2,0.2,0.4,0.1,0.1;
            0.4,0.4,0.1,0.1,0;
            0.1,0.3,0.3,0.2,0.1;
            0.3,0.2,0.2,0.2,0.1;
            0.1,0.3,0.5,0.1,0;
            0.2,0.3,0.3,0.1,0.1;
            0.2,0.3,0.35,0.15,0;
            0.1,0.3,0.4,0.1,0.1;
            0.1,0.4,0.3,0.1,0.1;
            0.3,0.4,0.2,0.1,0;
            0.1,0.4,0.3,0.1,0.1;
            0.2,0.3,0.4,0.1,0;
            0.4,0.3,0.2,0.1,0];
  disp('Eval Matrix:');
  disp(eval_mat);
  
  
  [m,n]=size(eval_mat);
  %disp([m,n]);
  
  %% 将上面的矩阵通过下标进行分组，每一组代表一个属性
  separation_points=[0,4,9,14];
  %然后再输出每一个属性下二级属性的权重
  w_mat={[0.2,0.3,0.3,0.2];
      [0.3,0.2,0.1,0.2,0.2];
      [0.1,0.2,0.3,0.2,0.2];
      [0.3,0.2,0.2,0.3]
      };
  %输出一级属性的权重
  w_vec=[0.4,0.3,0.2,0.1];
  
  %% 计算一级评判向量和二级评判矩阵
  separation_points(end+1)=m;
  eval_mat_seconds=[];%开辟一个空间存放矩阵
  for i=1:length(separation_points)-1
       % 从eval_mat中提取一个子矩阵，计算每个区间的二级评判矩阵
      temp_mat = eval_mat(separation_points(i)+1:separation_points(i+1),:);
      % 使用 w_mat{i} 对 temp_mat 进行加权求和
      eval_mat_seconds = [eval_mat_seconds; w_mat{i} * temp_mat];
  end
  disp("一级评判向量为：");
  disp(eval_mat_seconds);
  
  
  %% 计算二级评判向量，如果只有两级，即为最终结果
  eval_vec=w_vec*eval_mat_seconds;
  disp("最终的评价向量为：");
  disp(eval_vec);
  ~~~

  # 熵权法

  ## 步骤

  - 正向化处理

     ![image-20250119092958366](./数学建模.assets/image-20250119092958366.png)

  - 标准化处理

     ![image-20250119093422311](./数学建模.assets/image-20250119093422311.png)

  - 计算信息熵和熵权

     ![image-20250119093531098](./数学建模.assets/image-20250119093531098.png)

  ## 代码示例

~~~matlab
%% 极小型转极大型，传入参数为待正向化向量，返回为正向化后的结果
function [res] = Min2Max(X)
res=max(X)-X;
end

%% 中间型转极大型，传入参数为待正向化向量，返回为正向化后的结果
function [res]= Mid2Max(X,best)
    M=max(abs(X-best));
    res=1-abs(X-best)/M;
end

%% 区间型转极大型，传入参数为待正向化向量，返回为正向化后的结果
function [res] = Int2Max(X,a,b)
    M=max(a-min(X),max(X)-b);
    for i=1:size(X)
        if(X(i)<a)
            X(i)=1-(a-X(i))/M;
        elseif(X(i)>=a&&X(i)<=b)
            X(i)=1;
        elseif(X(i)>b)
            X(i)=1-(X(i)-b)/M;
        end
    end
    res=X;

end
~~~



  ~~~matlab
  %% 读取excel表
  X=xlsread("D:\Document\Excel\Blind date.xlsx");
  disp(X);
  
  %% 正向化
  disp("正在进行正向化");
  vec=input('请输入正向化向量组，以数组的形式输入，如[1,2,3]表示1，2，3列需要正向化，不需要正向化请输入-1\n');
  if(vec~=-1)
      for i=1:size(vec,2)
          flag=input(['第' num2str(vec(i)) '是那类数据（1.极小型，2.中间型，3.区间型，请输入序号：\n）']);
          if (flag==1)
              X(:,vec(i))=Min2Max( X(:,vec(i)));
          elseif (flag==2)
              best=input('请输入中间值的最好值:\n');
              temp=X(:,vec(i));
              X(:,vec(i))=Mid2Max(X(:,vec(i)),best);
          elseif (flag==3)
              arr=input('请输入最佳区间，按照[a,b]的形式输入:\n');
              X(:,vec(i))=Int2Max(X(:,vec(i)),arr(1),arr(2));
          end
      end
  end
  
  %% 标准化
  disp("正在进行标准化");
  [n,m]=size(X);
  %先检查有没有负元素
  isNeg=0;
  for i=1:n
      for j=1:m
          if(X(i,j)<0)
              isNeg=1;
              break;
          end
      end
  end
  if(isNeg==0)
      squere_x=(X.*X);%平方
      sum_x=sum(squere_x,1).^0.5;%按列求和，在开方
      stand_x=X./repmat(sum_x,n,1);%得到标准化后的结果
  else
      max_x=max(X,[],1);%按列找出最大元素
      min_x=min(X,[],1);%按列找出最小元素
      stand_x=X-repmat(min_x,n,1)./(repmat(max_x,n,1)-repmat(min_x,n,1));
  end
  
  %% 计算样本概率，信息熵和熵权
  disp('正在用熵权法确定权值');
  P=stand_x./repmat(sum(stand_x),n,1);
  %由于概率为ln(0)没有定义，我们需要手动把他调节为和0接近的数
  for i=1:n
      for j=1:m
          if (P(i,j)==0)
              P(i,j)=0.00001;
          end
      end
  end
  H_x=sum(-P.*log(P));%在matlab中，log（x）为ln（x），log10（x）为lg（x）
  e_j=H_x./log(n);
  d_j=1-e_j;
  %进行归一化，获得熵权
  disp('熵权完成，权值为：');
  w=d_j./sum(d_j);
  disp(w);
  ~~~

# TOPSIS

## 步骤

  - 指标正向化

     ![image-20250120154714410](./数学建模.assets/image-20250120154714410.png)

  - 标准化

     ![image-20250120154810212](./数学建模.assets/image-20250120154810212.png)

  * 用距离法打分

    ![image-20250124105249403](./数学建模.assets/image-20250124105249403.png)

  - 用优劣解进行打分

     ![image-20250120155913308](./数学建模.assets/image-20250120155913308.png)

  - 确定权重

     ![image-20250120160023571](./数学建模.assets/image-20250120160023571.png)

## 代码示例

**==正向化和标准化和熵权法相同==**

  ~~~matlab
  %% 导入数据
  %X=[99,0.010;100,0.012;98,0.040;97,0.033];
  X=xlsread('D:\BaiduNetdiskDownload\第5讲 Topsis\代码\工作簿1.xlsx');
  X=X(:,[2:5]);
  
  %% 正向化
  disp("正在进行正向化")
  vec=input('请输入正向化向量组，以数组的形式输入，如[1,2,3]表示1，2，3列需要正向化，不需要正向化请输入-1\n');
  if(vec~=-1)
      for i=1:size(vec,2)
          flag=input(['第' num2str(vec(i)) '是那类数据（1.极小型，2.中间型，3.区间型，请输入序号：\n）']);
          if (flag==1)
              X(:,vec(i))=Min2Max( X(:,vec(i)));
          elseif (flag==2)
              best=input('请输入中间值的最好值:\n');
              temp=X(:,vec(i));
              X(:,vec(i))=Mid2Max(X(:,vec(i)),best);
          elseif (flag==3)
              arr=input('请输入最佳区间，按照[a,b]的形式输入:\n');
              X(:,vec(i))=Int2Max(X(:,vec(i)),arr(1),arr(2));
          end
      end
      disp("所有数据都已经正向化完成")
  end
  
  %% 标准化
  disp("正在进行标准化");
  [n,m]=size(X);
  %先检查有没有负元素
  isNeg=0;
  for i=1:n
      for j=1:m
          if(X(i,j)<0)
              isNeg=1;
              break;
          end
      end
  end
  if(isNeg==0)
      squere_x=(X.*X);%平方
      sum_x=sum(squere_x,1).^0.5;%按列求和，在开方
      stand_x=X./repmat(sum_x,n,1);%得到标准化后的结果
  else
      max_x=max(X,[],1);%按列找出最大元素
      min_x=min(X,[],1);%按列找出最小元素
      stand_x=X-repmat(min_x,n,1)./(repmat(max_x,n,1)-repmat(min_x,n,1));
  end
  
  %% （法一）用距离法打分
  disp('用距离法打分')
  max_x=max(stand_x,[],1);
  min_x=min(stand_x,[],1);
  
  (stand_x-repmat(min_x,n,1))./(max_x-min_x)
  
  %% 用优劣解打分（先用距离法求解，否则没有min_x和max_x）
  disp('用优劣解打分')
  tmp=ones(m);%生成m行m列的1矩阵
  w_j=tmp(:,1);%取出第一列
  is_need_w=input('是否需要指定权值，如果需要请输入1，否则输入0:\n');
  if(is_need_w==1)
      w_j=input('请按列输入各指标权值，（如[0.1，0.2，0.3，0.4]）');
  end
  z_plus=repmat(max_x,n,1);
  z_sub=repmat(min_x,n,1);
  D_plus=sum(((stand_x-z_plus).^2)*w_j,2).^0.5;
  D_sub=sum(((stand_x-z_sub).^2)*w_j,2).^0.5;
  
  S=D_sub./(D_sub+D_plus);
  
  %将结果归一化
  res_topsis=S./sum(S);
  
  %将结果放入excel表中
  xlswrite('res_Topsis',res_topsis)
  ~~~

# 灰色关联度分析

## 步骤

  - 数据预处理/标准化

     **不同正向化和标准化可能导致结果有差异**！！！

     ![image-20250125094006561](./数学建模.assets/image-20250125094006561.png)

  - 确定分析序列

     ![image-20250125094059409](./数学建模.assets/image-20250125094059409.png)

  - 确定灰色关联系数

     ![image-20250125094210041](./数学建模.assets/image-20250125094210041.png)
     
     ![image-20250125094343139](./数学建模.assets/image-20250125094343139.png)

​                                                    ***具体解题步骤***

![image-20250125095351775](./数学建模.assets/image-20250125095351775.png)

## 概念

* 作用：确定那些是主要因素，那些是次要因素，消除多重共线性的问题，尽量不要用于综合评价（因为会由于与处理不同，导致结果出现不同）

![image-20250125094914041](./数学建模.assets/image-20250125094914041.png)

​                                                            ***同时也可以解决多重共线性问题***

![image-20250125095044145](./数学建模.assets/image-20250125095044145.png)

## 代码实现

* 可以直接用excel计算

* 用matlab计算

  ~~~matlab
  %% 导入数据
  X=xlsread('');
  
  %% 正向化
  disp("正在进行正向化")
  vec=input('请输入正向化向量组，以数组的形式输入，如[1,2,3]表示1，2，3列需要正向化，不需要正向化请输入-1\n');
  if(vec~=-1)
      for i=1:size(vec,2)
          flag=input(['第' num2str(vec(i)) '是那类数据（1.极小型，2.中间型，3.区间型，请输入序号：\n）']);
          if (flag==1)
              X(:,vec(i))=Min2Max( X(:,vec(i)));
          elseif (flag==2)
              best=input('请输入中间值的最好值:\n');
              temp=X(:,vec(i));
              X(:,vec(i))=Mid2Max(X(:,vec(i)),best);
          elseif (flag==3)
              arr=input('请输入最佳区间，按照[a,b]的形式输入:\n');
              X(:,vec(i))=Int2Max(X(:,vec(i)),arr(1),arr(2));
          end
      end
      disp("所有数据都已经正向化完成")
  end
  
  %% 标准化
  disp("正在进行标准化");
  [n,m]=size(X);
  %先检查有没有负元素
  isNeg=0;
  for i=1:n
      for j=1:m
          if(X(i,j)<0)
              isNeg=1;
              break;
          end
      end
  end
  if(isNeg==0)
      squere_x=(X.*X);%平方
      sum_x=sum(squere_x,1).^0.5;%按列求和，在开方
      stand_x=X./repmat(sum_x,n,1);%得到标准化后的结果
  else
      max_x=max(X,[],1);%按列找出最大元素
      min_x=min(X,[],1);%按列找出最小元素
      stand_x=X-repmat(min_x,n,1)./(repmat(max_x,n,1)-repmat(min_x,n,1));
  end
  
  %% 灰色关联度分析
  res=stand_x;
  GRE_X=[res,max(res,[],2)];%按行寻找最大数；注意这里我们把x0放到了最后一列
  [m,n]=size(GRE_X);
  gamma_X=zeros(m,n-1);
  for i=1:n-1
      gamma_X(:,i)=abs(GRE_X(:,i)-GRE_X(:,n));
  end
  b=max(max(gamma_X));
  a=min(min(gamma_X));
  roh=0.5;
  gamma_X=(a+roh*b)./(gamma_X+roh*b);
  gre_res=sum(gamma_X)./m;
  ~~~

  

# 线性规划

## 步骤

> 可以通过拉格朗日求最值的方法求得线性规划的解！

### 使用matlab解题步骤（线性规划可能存在无解和无穷解的情况）

* 转化为matlab所能看懂的标准型

![image-20250127093334211](./数学建模.assets/image-20250127093334211.png)

* matlab求解函数

  ![image-20250127093843368](./数学建模.assets/image-20250127093843368.png)
  
  ![image-20250131083518210](./数学建模.assets/image-20250131083518210.png)

## 代码示例

### 例题

![image-20250127095842494](./数学建模.assets/image-20250127095842494.png)

### 代码

~~~matlab
f=[-40;-30];
A=[1,-1,0,240;1,0,-1,120]';%在矩阵后加"'"可以转置矩阵
b=[6,-1,-1,1200]';
Aeq=[];
beq=[];
lb=[0;0];%两个变量的下界都是0
ub=[+inf;+inf];%两个变量的上界都是正无穷
[x,val]=linprog(f,A,b,Aeq,beq,lb,ub);%函数中如果不存在某项值，用"[]"来代替，最后的val由于之前转最小值时取负，现在应该在取负才是真正的值
~~~

# 整数规划

## 分类

### 第一类

> 整数规划中的特例

![image-20250131083824368](./数学建模.assets/image-20250131083824368.png)

#### 解决问题

* 背包问题

![image-20250131084330365](./数学建模.assets/image-20250131084330365.png)

* 指派问题

![image-20250131090749886](./数学建模.assets/image-20250131090749886.png)

> 两个问题的不同

![image-20250131090857068](./数学建模.assets/image-20250131090857068.png)

### 第二类-蒙特卡罗模拟

![image-20250131091858291](./数学建模.assets/image-20250131091858291.png)

## 代码实现

~~~matlab
%% 用蒙特卡洛解决建校问题
n=10000;%设置模拟次数
res_min=+Inf;
res_x=0;
for i=1:n
    x=randi([0,1],6,1);%生成一个6*1的0或1向量
    if(x(1)+x(2)+x(3)>=1&x(4)+x(6)>=1&x(3)+x(5)>=1&x(2)+x(4)>=1&x(5)+x(6)>=1&x(1)>=1&x(2)+x(4)+x(6)>=1)
        sum_x=sum(x);
        if(sum_x<res_min)
            res_x=x;
            res_min=sum_x;
        end
    end
end

%% 用蒙特卡洛解决工厂分配设备问题
n=10000;%设置模拟次数
c=[4,2,3,4;
    6,4,5,5;
    7,6,7,5;
    7,8,8,6;
    7,9,8,6;
    7,10,8,6];
res_x=0;
res=0;
for k=1:n
    flag=1;
    x=randi([1,4],1,6);%生成一个1*6的向量，元素为1~4的整数，表示该设备分配给了哪个企业
    for j=1:4%检查每个企业至少分配一台
        if(ismember(j,x)==0) %ismember(j,x)表示x向量中是否有j这个元素，有返回1，没有返回0
            flag=0;
            break;
        end
    end

    if (flag==1)
        sum=0;
        for j=1:6
            sum=sum+c(j,x(j));
        end
        if(sum>res)
            res=sum;
            res_x=x;
        end
    end
end

%% 蒙特卡洛模拟
a=10;%木纹间距
L=5;%表示针的长度
n=100000;%投掷次数
ph=rand(n,1)*pi;%随机抛针，得到角度
x=rand(n,1)*a/2;%针的中心到最近木纹的距离
m=0;%表示相交的次数
y=(L/2)*sin(ph);%恰好相交边界的情况
axis=([0,pi,0,a/2]);%先设置坐标轴
box on;%让图hold住不要动，否则会绘制一张新图
for i=1:n
    if(x(i)<=y(i))
        m=m+1;
        plot(ph(i),x(i),'b.');
        hold on
    end
end
P=m/n;
mypi=2*L/(P*a);

%% 解决张麻子问题
n=10000;%设置模拟次数
x1=round(1+rand(n,1)*5);%round是4舍5入取整的函数
x2=randi([1,6],n,1);
res_x1=0;
res_x2=0;
max_y=0;
for i=1:n
    if(x1(i)+x2(i)<=6)
        if(240*x1(i)+120*x2(i)<=1200)
            if(40*x1(i)+30*x2(i)>max_y)
                max_y=40*x1(i)+30*x2(i);
                res_x1=x1(i);
                res_x2=x2(i);
            end
        end
    end
end
~~~

