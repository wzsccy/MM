  # 层次分析法

* 只有非一致矩阵才需要进行一致性检测

* ==要先进行一致性检测，通过后才能求权重！！！==

  ## 步骤

![image-20250121103417269](./数学建模.assets/image-20250121103417269.png)

  ## 代码实现

~~~matlab
%% 识别判断矩阵
disp('请输入判断矩阵A')
A=input('A=');
[n,n]=size(A);
%% 计算一致性比例CR
CI=(Max_eig-n)/(n-1);
RI=[0 0.0001 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59];%这里的RI最多支持n等于15
CR=CI/RI(n);
disp('最大特征值为：');
disp(Max_eig);
disp('一致性指标CI=');disp(CI);
disp('一致性比例CR=');disp(CR);
if CR<0.10
    disp('CR<0.01,该判断矩阵的一致性可以接受');
else 
    disp('注意：CR>=0.10,该判断矩阵需要进行修改！');
end
%% 方法1：算术平均法求权重
Sum_A=sum(A);%将矩阵按列去和
SUM_A=repmat(Sum_A,n,1);%将矩阵A作为元素填充到n行1列的矩阵里
Stand_A=A./SUM_A;
disp('计算算数平均值的结果:');
w1=sum(Stand_A,2)./n;
disp(w1)
%% 方法2：特征值法求权重
[V,D]=eig(A);%求矩阵A的全部特征值，构成对角阵D，并求A的向量构成列向量（V中的每一列都是D中与之相同列的特征值的特征向量）
Max_eig=max(max(D));%先行后列，求最大特征值
[r,c]=find(D==Max_eig,1);%找到最大特征值，返回前一个最大特征值的行列值
disp('特征值求权重的结果为：');
w2=V(:,c)./sum(V(:,c));
disp(w2)  
disp('两种方法的平均权值为：  ');
disp((w1+w2)./2); 
~~~

  # 模糊综合评价

* 权重做乘数，矩阵做被乘数

  ## 步骤

![image-20250121103926851](./数学建模.assets/image-20250121103926851.png)

  ## 代码示例

  ~~~matlab
  eval_mat=[0.8,0.15,0.05,0,0;
            0.2,0.6,0.1,0,0;
            0.5,0.4,0.1,0,0;
            0.1,0.3,0.5,0.05,0.05;
            0.3,0.5,0.15,0.05,0;
            0.2,0.2,0.4,0.1,0.1;
            0.4,0.4,0.1,0.1,0;
            0.1,0.3,0.3,0.2,0.1;
            0.3,0.2,0.2,0.2,0.1;
            0.1,0.3,0.5,0.1,0;
            0.2,0.3,0.3,0.1,0.1;
            0.2,0.3,0.35,0.15,0;
            0.1,0.3,0.4,0.1,0.1;
            0.1,0.4,0.3,0.1,0.1;
            0.3,0.4,0.2,0.1,0;
            0.1,0.4,0.3,0.1,0.1;
            0.2,0.3,0.4,0.1,0;
            0.4,0.3,0.2,0.1,0];
  disp('Eval Matrix:');
  disp(eval_mat);
  
  
  [m,n]=size(eval_mat);
  %disp([m,n]);
  
  %% 将上面的矩阵通过下标进行分组，每一组代表一个属性
  separation_points=[0,4,9,14];
  %然后再输出每一个属性下二级属性的权重
  w_mat={[0.2,0.3,0.3,0.2];
      [0.3,0.2,0.1,0.2,0.2];
      [0.1,0.2,0.3,0.2,0.2];
      [0.3,0.2,0.2,0.3]
      };
  %输出一级属性的权重
  w_vec=[0.4,0.3,0.2,0.1];
  
  %% 计算一级评判向量和二级评判矩阵
  separation_points(end+1)=m;
  eval_mat_seconds=[];%开辟一个空间存放矩阵
  for i=1:length(separation_points)-1
       % 从eval_mat中提取一个子矩阵，计算每个区间的二级评判矩阵
      temp_mat = eval_mat(separation_points(i)+1:separation_points(i+1),:);
      % 使用 w_mat{i} 对 temp_mat 进行加权求和
      eval_mat_seconds = [eval_mat_seconds; w_mat{i} * temp_mat];
  end
  disp("一级评判向量为：");
  disp(eval_mat_seconds);
  
  
  %% 计算二级评判向量，如果只有两级，即为最终结果
  eval_vec=w_vec*eval_mat_seconds;
  disp("最终的评价向量为：");
  disp(eval_vec);
  ~~~

  # 熵权法

  ## 步骤

  - 正向化处理

     ![image-20250119092958366](./数学建模.assets/image-20250119092958366.png)

  - 标准化处理

     ![image-20250119093422311](./数学建模.assets/image-20250119093422311.png)

  - 计算信息熵和熵权

     ![image-20250119093531098](./数学建模.assets/image-20250119093531098.png)

## 代码示例

~~~matlab
%% 极小型转极大型，传入参数为待正向化向量，返回为正向化后的结果
function [res] = Min2Max(X)
res=max(X)-X;
end

%% 中间型转极大型，传入参数为待正向化向量，返回为正向化后的结果
function [res]= Mid2Max(X,best)
    M=max(abs(X-best));
    res=1-abs(X-best)/M;
end

%% 区间型转极大型，传入参数为待正向化向量，返回为正向化后的结果
function [res] = Int2Max(X,a,b)
    M=max(a-min(X),max(X)-b);
    for i=1:size(X)
        if(X(i)<a)
            X(i)=1-(a-X(i))/M;
        elseif(X(i)>=a&&X(i)<=b)
            X(i)=1;
        elseif(X(i)>b)
            X(i)=1-(X(i)-b)/M;
        end
    end
    res=X;

end
~~~



  ~~~matlab
  %% 读取excel表
  X=xlsread("D:\Document\Excel\Blind date.xlsx");
  disp(X);
  
  %% 正向化
  disp("正在进行正向化");
  vec=input('请输入正向化向量组，以数组的形式输入，如[1,2,3]表示1，2，3列需要正向化，不需要正向化请输入-1\n');
  if(vec~=-1)
      for i=1:size(vec,2)
          flag=input(['第' num2str(vec(i)) '是那类数据（1.极小型，2.中间型，3.区间型，请输入序号：\n）']);
          if (flag==1)
              X(:,vec(i))=Min2Max( X(:,vec(i)));
          elseif (flag==2)
              best=input('请输入中间值的最好值:\n');
              temp=X(:,vec(i));
              X(:,vec(i))=Mid2Max(X(:,vec(i)),best);
          elseif (flag==3)
              arr=input('请输入最佳区间，按照[a,b]的形式输入:\n');
              X(:,vec(i))=Int2Max(X(:,vec(i)),arr(1),arr(2));
          end
      end
  end
  
  %% 标准化
  disp("正在进行标准化");
  [n,m]=size(X);
  %先检查有没有负元素
  isNeg=0;
  for i=1:n
      for j=1:m
          if(X(i,j)<0)
              isNeg=1;
              break;
          end
      end
  end
  if(isNeg==0)
      squere_x=(X.*X);%平方
      sum_x=sum(squere_x,1).^0.5;%按列求和，在开方
      stand_x=X./repmat(sum_x,n,1);%得到标准化后的结果
  else
      max_x=max(X,[],1);%按列找出最大元素
      min_x=min(X,[],1);%按列找出最小元素
      stand_x=X-repmat(min_x,n,1)./(repmat(max_x,n,1)-repmat(min_x,n,1));
  end
  
  %% 计算样本概率，信息熵和熵权
  disp('正在用熵权法确定权值');
  P=stand_x./repmat(sum(stand_x),n,1);
  %由于概率为ln(0)没有定义，我们需要手动把他调节为和0接近的数
  for i=1:n
      for j=1:m
          if (P(i,j)==0)
              P(i,j)=0.00001;
          end
      end
  end
  H_x=sum(-P.*log(P));%在matlab中，log（x）为ln（x），log10（x）为lg（x）
  e_j=H_x./log(n);
  d_j=1-e_j;
  %进行归一化，获得熵权
  disp('熵权完成，权值为：');
  w=d_j./sum(d_j);
  disp(w);
  ~~~

# TOPSIS

  ## 步骤

  - 指标正向化

     ![image-20250120154714410](./数学建模.assets/image-20250120154714410.png)

  - 标准化

     ![image-20250120154810212](./数学建模.assets/image-20250120154810212.png)

  * 用距离法打分

    ![image-20250124105249403](./数学建模.assets/image-20250124105249403.png)

  - 用优劣解进行打分

     ![image-20250120155913308](./数学建模.assets/image-20250120155913308.png)

  - 确定权重

     ![image-20250120160023571](./数学建模.assets/image-20250120160023571.png)

## 代码示例

**==正向化和标准化和熵权法相同==**

  ~~~matlab
  %% 导入数据
  X=[99,0.010;100,0.012;98,0.040;97,0.033];
  
  %% 正向化
  disp("正在进行正向化")
  vec=input('请输入正向化向量组，以数组的形式输入，如[1,2,3]表示1，2，3列需要正向化，不需要正向化请输入-1\n');
  if(vec~=-1)
      for i=1:size(vec,2)
          flag=input(['第' num2str(vec(i)) '是那类数据（1.极小型，2.中间型，3.区间型，请输入序号：\n）']);
          if (flag==1)
              X(:,vec(i))=Min2Max( X(:,vec(i)));
          elseif (flag==2)
              best=input('请输入中间值的最好值:\n');
              temp=X(:,vec(i));
              X(:,vec(i))=Mid2Max(X(:,vec(i)),best);
          elseif (flag==3)
              arr=input('请输入最佳区间，按照[a,b]的形式输入:\n');
              X(:,vec(i))=Int2Max(X(:,vec(i)),arr(1),arr(2));
          end
      end
      disp("所有数据都已经正向化完成")
  end
  
  %% 标准化
  disp("正在进行标准化");
  [n,m]=size(X);
  %先检查有没有负元素
  isNeg=0;
  for i=1:n
      for j=1:m
          if(X(i,j)<0)
              isNeg=1;
              break;
          end
      end
  end
  if(isNeg==0)
      squere_x=(X.*X);%平方
      sum_x=sum(squere_x,1).^0.5;%按列求和，在开方
      stand_x=X./repmat(sum_x,n,1);%得到标准化后的结果
  else
      max_x=max(X,[],1);%按列找出最大元素
      min_x=min(X,[],1);%按列找出最小元素
      stand_x=X-repmat(min_x,n,1)./(repmat(max_x,n,1)-repmat(min_x,n,1));
  end
  
  %% （法一）用距离法打分
  disp('用距离法打分')
  max_x=max(stand_x,[],1);
  min_x=min(stand_x,[],1);
  
  (stand_x-repmat(min_x,n,1))./(max_x-min_x)
  
  %%  (法二) 用优劣解打分
  disp('用优劣解打分')
  tmp=ones(m);%生成m行m列的1矩阵
  w_j=tmp(:,1);%取出第一列
  is_need_w=input('是否需要指定权值，如果需要请输入1，否则输入0:\n');
  if(is_need_w==1)
      w_j=input('请按列输入各指标权值，（如[0.1，0.2，0.3，0.4]）');
  end
  z_plus=repmat(max_x,n,1);
  z_sub=repmat(min_x,n,1);
  D_plus=sum(((stand_x-z_plus).^2)*w_j,2).^0.5;
  D_sub=sum(((stand_x-z_sub).^2)*w_j,2).^0.5;
  
  S=D_sub./(D_sub+D_plus);
  
  %将结果归一化
  res_topsis=S./sum(S);
  ~~~

